

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      CachetAPI.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.3.0/highlightjs-line-numbers.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <link type="text/css" rel="stylesheet" href="styles/monokai-sublime.css">

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      OIP HDMW
    </h3>

    <h3>Classes</h3><ul><li id="CachetAPI-nav"><a href="CachetAPI.html">CachetAPI</a><ul class='methods'><li data-type="method" id="CachetAPI-addComponent-nav"><a href="CachetAPI.html#addComponent">addComponent</a></li><li data-type="method" id="CachetAPI-addComponentGroup-nav"><a href="CachetAPI.html#addComponentGroup">addComponentGroup</a></li><li data-type="method" id="CachetAPI-addIncident-nav"><a href="CachetAPI.html#addIncident">addIncident</a></li><li data-type="method" id="CachetAPI-addIncidentUpdate-nav"><a href="CachetAPI.html#addIncidentUpdate">addIncidentUpdate</a></li><li data-type="method" id="CachetAPI-addMetric-nav"><a href="CachetAPI.html#addMetric">addMetric</a></li><li data-type="method" id="CachetAPI-addMetricPoint-nav"><a href="CachetAPI.html#addMetricPoint">addMetricPoint</a></li><li data-type="method" id="CachetAPI-addSubscriber-nav"><a href="CachetAPI.html#addSubscriber">addSubscriber</a></li><li data-type="method" id="CachetAPI-deleteComponent-nav"><a href="CachetAPI.html#deleteComponent">deleteComponent</a></li><li data-type="method" id="CachetAPI-deleteComponentGroup-nav"><a href="CachetAPI.html#deleteComponentGroup">deleteComponentGroup</a></li><li data-type="method" id="CachetAPI-deleteIncident-nav"><a href="CachetAPI.html#deleteIncident">deleteIncident</a></li><li data-type="method" id="CachetAPI-deleteIncidentUpdate-nav"><a href="CachetAPI.html#deleteIncidentUpdate">deleteIncidentUpdate</a></li><li data-type="method" id="CachetAPI-deleteMetric-nav"><a href="CachetAPI.html#deleteMetric">deleteMetric</a></li><li data-type="method" id="CachetAPI-deleteMetricPoint-nav"><a href="CachetAPI.html#deleteMetricPoint">deleteMetricPoint</a></li><li data-type="method" id="CachetAPI-deleteSubscriber-nav"><a href="CachetAPI.html#deleteSubscriber">deleteSubscriber</a></li><li data-type="method" id="CachetAPI-getComponent-nav"><a href="CachetAPI.html#getComponent">getComponent</a></li><li data-type="method" id="CachetAPI-getComponentGroup-nav"><a href="CachetAPI.html#getComponentGroup">getComponentGroup</a></li><li data-type="method" id="CachetAPI-getComponentGroups-nav"><a href="CachetAPI.html#getComponentGroups">getComponentGroups</a></li><li data-type="method" id="CachetAPI-getComponents-nav"><a href="CachetAPI.html#getComponents">getComponents</a></li><li data-type="method" id="CachetAPI-getIncident-nav"><a href="CachetAPI.html#getIncident">getIncident</a></li><li data-type="method" id="CachetAPI-getIncidents-nav"><a href="CachetAPI.html#getIncidents">getIncidents</a></li><li data-type="method" id="CachetAPI-getIncidentUpdate-nav"><a href="CachetAPI.html#getIncidentUpdate">getIncidentUpdate</a></li><li data-type="method" id="CachetAPI-getIncidentUpdates-nav"><a href="CachetAPI.html#getIncidentUpdates">getIncidentUpdates</a></li><li data-type="method" id="CachetAPI-getMetric-nav"><a href="CachetAPI.html#getMetric">getMetric</a></li><li data-type="method" id="CachetAPI-getMetricPoints-nav"><a href="CachetAPI.html#getMetricPoints">getMetricPoints</a></li><li data-type="method" id="CachetAPI-getMetrics-nav"><a href="CachetAPI.html#getMetrics">getMetrics</a></li><li data-type="method" id="CachetAPI-getSubscribers-nav"><a href="CachetAPI.html#getSubscribers">getSubscribers</a></li><li data-type="method" id="CachetAPI-getVersion-nav"><a href="CachetAPI.html#getVersion">getVersion</a></li><li data-type="method" id="CachetAPI-ping-nav"><a href="CachetAPI.html#ping">ping</a></li><li data-type="method" id="CachetAPI-updateComponent-nav"><a href="CachetAPI.html#updateComponent">updateComponent</a></li><li data-type="method" id="CachetAPI-updateComponentGroup-nav"><a href="CachetAPI.html#updateComponentGroup">updateComponentGroup</a></li><li data-type="method" id="CachetAPI-updateIncident-nav"><a href="CachetAPI.html#updateIncident">updateIncident</a></li><li data-type="method" id="CachetAPI-updateIncidentUpdate-nav"><a href="CachetAPI.html#updateIncidentUpdate">updateIncidentUpdate</a></li></ul></li></ul><h3 id="global-nav"><a href="global.html">Global</a></h3>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        CachetAPI.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>import axios from 'axios'

class CachetAPI {
	/**
	 * Create a new CachetAPI
	 * @param  {Object} options - Options about the CachetAPI Instance
	 * @param {String} options.url - The URL of the CachetAPI Instance
	 * @param {String} [options.apiToken] - The API Token for the CachetAPI Instance
	 * @return {CachetAPI}
	 *
	 * @example
	 * import CachetAPI from 'cachetapi'
	 *
	 * let cachet_api = new CachetAPI({
	 * 	url: "https://demo.cachethq.io/api",
	 * 	apiToken: "9yMHsdioQosnyVK4iCVR"
	 * })
	 */
	constructor(options){
		if (!options || !options.url)
			throw new Error("Error! options.url a is required option!")

		this.options = options

		this.api = axios.create({ baseURL: this.options.url, headers: {"X-Cachet-Token": this.options.apiToken} })
	}


	/* ----------------- GENERAL ----------------- */
	/**
	 * Ping the CachetAPI server and get back a response
	 * @return {Promise&lt;String>} Responds with "Pong!" when online
	 *
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let response = await cachet_api.ping()
	 * // response = "Pong!"
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.ping().then((response) => {
	 * 	// response = "Pong!"
	 * }).catch((error) => { })
	 */
	async ping(){
		let response 

		let url = "/v1/ping"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		return response.data.data
	}
	/**
	 * Get the version of the CachetAPI server
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {String|Object} Returns the current version as a string OR an Object if `with_meta` is `true`
	 *
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let version = await cachet_api.getVersion()
	 * // version = "2.4.0-dev"
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getVersion().then((version) => {
	 * 	// version = "2.4.0-dev"
	 * }).catch((error) => { })
	 */
	async getVersion(with_meta){
		let response 

		let url = "/v1/version"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}

	/* ----------------- COMPONENTS ----------------- */
	/**
	 * @typedef {Object} Component
	 * @property {String} name - Name of the Component
	 * @property {String} description - Description of the Component
	 * @property {Integer} status - Status of the Component (See the {@link https://docs.cachethq.io/v1.0/docs/component-statuses Cachet Docs})
	 * @property {String} [id] - The id of the Component
	 * @property {String} [link] - A hyperlink to the Component
	 * @property {Integer} [order] - Order of the Component
	 * @property {Integer} [group_id] - The group id that the Component is within
	 * @property {Boolean} [enabled] - Whether the Component is enabled
	 */
	/**
	 * Get all the Components
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;Component>>} Returns an Array of Components
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let components = await cachet_api.getComponents()
	 * // components = [{@link Component}, {@link Component}, {@link Component}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getComponents().then((components) => {
	 * 	// components = [{@link Component}, {@link Component}, {@link Component}]
	 * }).catch((error) => { })
	 */
	async getComponents(with_meta){
		let response 

		let url = "/v1/components"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}	

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}
	/**
	 * Get a Component
	 * @param  {Integer} component_id - The ID of the Component you wish to get
	 * @return {Promise&lt;Component>} Returns a component
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component = await cachet_api.getComponent(0)
	 * // component = {@link Component}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getComponent(0).then((component) => {
	 * 	// component = {@link Component}
	 * }).catch((error) => { })
	 */
	async getComponent(component_id){
		let response 

		let url = "/v1/components/" + component_id

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Component
	 * @param  {Component} component - The Component you wish to add
	 * @return {Promise&lt;Component>} Returns a component
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component = await cachet_api.addComponent({
	 * 	name: "My Component",
	 * 	description: "My Description",
	 * 	status: 0
	 * })
	 * // component = {@link Component}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addComponent({
	 * 	name: "My Component",
	 * 	description: "My Description",
	 * 	status: 0
	 * }).then((component) => {
	 * 	// component = {@link Component}
	 * }).catch((error) => { })
	 */
	async addComponent(component){
		let response 

		let url = "/v1/components"

		try {
			response = await this.api.post(url, component)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Update a Component
	 * @param  {Integer} component_id - The ID of the Component you wish to update
	 * @param  {Component} component - The updated Component info
	 * @return {Promise&lt;Component>} Returns a component
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component = await cachet_api.updateComponent(0, {
	 * 	name: "My Updated Component",
	 * 	status: 1
	 * })
	 * // component = {@link Component}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.updateComponent(0, {
	 * 	name: "My Updated Component",
	 * 	status: 1
	 * }).then((component) => {
	 * 	// component = {@link Component}
	 * }).catch((error) => { })
	 */
	async updateComponent(component_id, component){
		let response 

		let url = "/v1/components/" + component_id

		try {
			response = await this.api.put(url, component)
		} catch (e) {
			throw this.createError(url, 'PUT', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete a Component
	 * @param  {Integer} component_id - The ID of the Component you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if component deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteComponent(0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteComponent(0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteComponent(component_id){
		let response 

		let url = "/v1/components/" + component_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- COMPONENT GROUPS ----------------- */
	/**
	 * @typedef {Object} ComponentGroup
	 * @property {String} name - Name of the Component Group
	 * @property {Integer} [order] - Order of the Component Group
	 * @property {Integer} [collapsed] - Whether the Component Group is collapsed (0 = no, 1 = yes, 2 = if a component status is not Operational)
	 */
	/**
	 * Get all the Component Groups
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;ComponentGroup>>} Returns an Array of Component Groups
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component_groups = await cachet_api.getComponentGroups()
	 * // component_groups = [{@link ComponentGroup}, {@link ComponentGroup}, {@link ComponentGroup}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getComponentGroups().then((component_groups) => {
	 * 	// component_groups = [{@link ComponentGroup}, {@link ComponentGroup}, {@link ComponentGroup}]
	 * }).catch((error) => { })
	 */
	async getComponentGroups(with_meta){
		let response 

		let url = "/v1/components/groups"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}	

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}
	/**
	 * Get a Component Group
	 * @param  {Integer} group_id - The ID of the Component Group you wish to get
	 * @return {Promise&lt;ComponentGroup>} Returns a Component Group
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component_group = await cachet_api.getComponentGroup(0)
	 * // component_group = {@link ComponentGroup}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getComponentGroup(0).then((component_group) => {
	 * 	// component_group = {@link ComponentGroup}
	 * }).catch((error) => { })
	 */
	async getComponentGroup(group_id){
		let response 

		let url = "/v1/components/groups/" + group_id

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Component Group
	 * @param  {ComponentGroup} group - The Component Group you wish to add
	 * @return {Promise&lt;ComponentGroup>} Returns a Component Group
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component_group = await cachet_api.addComponentGroup({
	 * 	name: "My Component Group"
	 * })
	 * // component_group = {@link ComponentGroup}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addComponentGroup({
	 * 	name: "My Component Group"
	 * }).then((component_group) => {
	 * 	// component_group = {@link ComponentGroup}
	 * }).catch((error) => { })
	 */
	async addComponentGroup(group){
		let response 

		let url = "/v1/components/groups"

		try {
			response = await this.api.post(url, group)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Update a Component Group
	 * @param  {Integer} group_id - The ID of the Component Group you wish to update
	 * @param  {ComponentGroup} group - The updated Component Group info
	 * @return {Promise&lt;ComponentGroup>} Returns a component
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let component_group = await cachet_api.updateComponentGroup(0, {
	 * 	name: "My Updated Component Group"
	 * })
	 * // component_group = {@link ComponentGroup}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.updateComponentGroup(0, {
	 * 	name: "My Updated Component Group"
	 * }).then((component_group) => {
	 * 	// component_group = {@link ComponentGroup}
	 * }).catch((error) => { })
	 */
	async updateComponentGroup(group_id, group){
		let response 

		let url = "/v1/components/groups/" + group_id

		try {
			response = await this.api.put(url, group)
		} catch (e) {
			throw this.createError(url, 'PUT', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete a ComponentGroup
	 * @param  {Integer} group_id - The ID of the Component Group you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if Component Group deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteComponentGroup(0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteComponentGroup(0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteComponentGroup(group_id){
		let response 

		let url = "/v1/components/groups/" + group_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- INCIDENTS ----------------- */
	/**
	 * @typedef {Object} Incident
	 * @property {String} name - Name of the Incident
	 * @property {String} message - The Incident message
	 * @property {Integer} status - Status of the Incident (See the {@link https://docs.cachethq.io/v1.0/docs/incident-statuses Cachet Docs})
	 * @property {Integer} visible - 0 to hide, 1 to show
	 * @property {String} [component_id] - Component to update. (Required with component_status)
	 * @property {String} [component_status] - The status to update the given component with
	 * @property {Boolean} [notify] - Whether to notify subscribers
	 * @property {Integer} [created_at] - When the Incident was created
	 * @property {String} [template] - The template slug to use.
	 * @property {Array.&lt;String>} [vars] - The variables to pass to the template.
	 */
	/**
	 * Get all the Incidents
	 * @param  {Boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;Incident>>} Returns an Array of Incidents
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident = await cachet_api.getIncidents()
	 * // incident = [{@link Incident}, {@link Incident}, {@link Incident}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getIncidents().then((incident) => {
	 * 	// incident = [{@link Incident}, {@link Incident}, {@link Incident}]
	 * }).catch((error) => { })
	 */
	async getIncidents(with_meta){
		let response 

		let url = "/v1/incidents"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}	

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}
	/**
	 * Get an Incident
	 * @param  {Integer} incident_id - The ID of the Incident you wish to get
	 * @return {Promise&lt;Incident>} Returns an Incident
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident = await cachet_api.getIncident(0)
	 * // incident = {@link Incident}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getIncident(0).then((incident) => {
	 * 	// incident = {@link Incident}
	 * }).catch((error) => { })
	 */
	async getIncident(incident_id){
		let response 

		let url = "/v1/incidents/" + incident_id

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Incident
	 * @param  {Incident} incident - The Incident you wish to add
	 * @return {Promise&lt;Incident>} Returns an Incident
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident = await cachet_api.addIncident({
	 * 	name: "My Incident",
	 * 	message: "My Incident message",
	 * 	status: 0,
	 * 	visible: 1
	 * })
	 * // incident = {@link Incident}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addIncident({
	 * 	name: "My Incident",
	 * 	message: "My Incident message",
	 * 	status: 0,
	 * 	visible: 1
	 * }).then((incident) => {
	 * 	// incident = {@link Incident}
	 * }).catch((error) => { })
	 */
	async addIncident(incident){
		let response 

		let url = "/v1/incidents"

		try {
			response = await this.api.post(url, incident)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Update an Incident
	 * @param  {Integer} incident_id - The ID of the Incident you wish to update
	 * @param  {Incident} incident - The updated Incident info
	 * @return {Promise&lt;Incident>} Returns an Incident
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident = await cachet_api.updateIncident(0, {
	 * 	name: "My Updated Incident",
	 * 	status: 1
	 * })
	 * // incident = {@link Incident}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.updateIncident(0, {
	 * 	name: "My Updated Incident",
	 * 	status: 1
	 * }).then((incident) => {
	 * 	// incident = {@link Incident}
	 * }).catch((error) => { })
	 */
	async updateIncident(incident_id, incident){
		let response 

		let url = "/v1/incidents/" + incident_id

		try {
			response = await this.api.put(url, incident)
		} catch (e) {
			throw this.createError(url, 'PUT', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete an Incident
	 * @param  {Integer} incident_id - The ID of the Incident you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if the Incident deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteIncident(0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteIncident(0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteIncident(incident_id){
		let response 

		let url = "/v1/incidents/" + incident_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- INCIDENT UPDATES ----------------- */
	/**
	 * @typedef {Object} IncidentUpdate
	 * @property {String} message - Description of the Incident Update
	 * @property {Integer} status - Status of the Incident Update (See the {@link https://docs.cachethq.io/v1.0/docs/incident-statuses Cachet Docs})
	 */
	/**
	 * Get all the IncidentUpdates for a specific Incident
	 * @param  {Integer} incident_id - The ID of the Incident you wish to get Incident Updates for
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;IncidentUpdate>>} Returns an Array of IncidentUpdates
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident_updates = await cachet_api.getIncidentUpdates()
	 * // incident_updates = [{@link IncidentUpdate}, {@link IncidentUpdate}, {@link IncidentUpdate}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getIncidentUpdates().then((incident_updates) => {
	 * 	// incident_updates = [{@link IncidentUpdate}, {@link IncidentUpdate}, {@link IncidentUpdate}]
	 * }).catch((error) => { })
	 */
	async getIncidentUpdates(incident_id, with_meta){
		let response 

		let url = "/v1/incidents/" + incident_id + "/updates" 

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}	

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}
	/**
	 * Get an Incident Update
	 * @param  {Integer} incident_id - The ID of the Incident you wish to get the specific Incident Update from
	 * @param  {Integer} update_id - The ID of the Incident Update you wish to get
	 * @return {Promise&lt;IncidentUpdate>} Returns an Incident Update
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident_update = await cachet_api.getIncidentUpdate(0, 0)
	 * // incident_update = {@link IncidentUpdate}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getIncidentUpdate(0, 0).then((incident_update) => {
	 * 	// incident_update = {@link IncidentUpdate}
	 * }).catch((error) => { })
	 */
	async getIncidentUpdate(incident_id, update_id){
		let response 

		let url = "/v1/incidents/" + incident_id + "/updates/" + update_id

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Incident Update
	 * @param  {Integer} incident_id - The ID of the Incident you wish to add an Incident Updates to
	 * @param  {IncidentUpdate} update - The Incident Update you wish to add
	 * @return {Promise&lt;IncidentUpdate>} Returns an IncidentUpdate
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident_update = await cachet_api.addIncidentUpdate(0, {
	 * 	message: "My Update",
	 * 	status: 2
	 * })
	 * // incident_update = {@link IncidentUpdate}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addIncidentUpdate(0, {
	 * 	message: "My Update",
	 * 	status: 2
	 * }).then((incident_update) => {
	 * 	// incident_update = {@link IncidentUpdate}
	 * }).catch((error) => { })
	 */
	async addIncidentUpdate(incident_id, update){
		let response 

		let url = "/v1/incidents/" + incident_id + "/updates"

		try {
			response = await this.api.post(url, update)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Update an Incident Update
	 * @param  {Integer} incident_id - The ID of the Incident that you wish to update an Incident Updates on
	 * @param  {Integer} update_id - The ID of the Incident Update you wish to update
	 * @param  {IncidentUpdate} update - The updated IncidentUpdate
	 * @return {Promise&lt;IncidentUpdate>} Returns a component
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let incident_update = await cachet_api.updateIncidentUpdate(0, 0, {
	 * 	message: "My Updated Message",
	 * 	status: 4
	 * })
	 * // incident_update = {@link IncidentUpdate}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.updateIncidentUpdate(0, 0, {
	 * 	message: "My Updated Message",
	 * 	status: 4
	 * }).then((incident_update) => {
	 * 	// incident_update = {@link IncidentUpdate}
	 * }).catch((error) => { })
	 */
	async updateIncidentUpdate(incident_id, update_id, update){
		let response 

		let url = "/v1/incidents/" + incident_id + "/updates/" + update_id

		try {
			response = await this.api.put(url, update)
		} catch (e) {
			throw this.createError(url, 'PUT', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete an Incident Update
	 * @param  {Integer} incident_id - The ID of the Incident that you wish to delete an Incident Updates from
	 * @param  {Integer} update_id - The ID of the Incident Update you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if Incident Update deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteIncidentUpdate(0, 0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteIncidentUpdate(0, 0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteIncidentUpdate(incident_id, update_id){
		let response 

		let url = "/v1/incidents/" + incident_id + "/updates/" + update_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- METRICS ----------------- */
	/**
	 * @typedef {Object} Metric
	 * @property {String} name - Name of the Metric
	 * @property {String} description - Description of what the metric is measuring
	 * @property {Integer} suffix - Measurments in
	 * @property {Integer} default_value - The default value to use when a point is added
	 * @property {Boolean} [display_chart] - Whether the Chart for the metric should be displayed
	 */
	/**
	 * Get all the Metrics
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;Metric>>} Returns an Array of Metrics
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let metrics = await cachet_api.getMetrics()
	 * // metrics = [{@link Metric}, {@link Metric}, {@link Metric}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getMetrics().then((metrics) => {
	 * 	// metrics = [{@link Metric}, {@link Metric}, {@link Metric}]
	 * }).catch((error) => { })
	 */
	async getMetrics(with_meta){
		let response 

		let url = "/v1/metrics"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}	

		// If the user would like the "meta" data returned as well, they need to set the with_meta flag
		// otherwise, we will just return an array of Components 
		// (since its nicer to work with than always doing .data on the response)
		if (with_meta)
			return response.data
		else
			return response.data.data
	}
	/**
	 * Get a Metric
	 * @param  {Integer} metric_id - The ID of the Metric you wish to get
	 * @return {Promise&lt;Metric>} Returns a Metric
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let metric = await cachet_api.getMetric(0)
	 * // metric = {@link Metric}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getMetric(0).then((metric) => {
	 * 	// metric = {@link Metric}
	 * }).catch((error) => { })
	 */
	async getMetric(metric_id){
		let response 

		let url = "/v1/metrics/" + metric_id

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Metric
	 * @param  {Metric} metric - The Metric you wish to add
	 * @return {Promise&lt;Metric>} Returns a Metric
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let metric = await cachet_api.addMetric({
	 * 	name: "My Metric",
	 * 	suffix: "F",
	 * 	description: "My Metric Description",
	 * 	default_value: 1
	 * })
	 * // metric = {@link Metric}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addMetric({
	 * 	name: "My Metric",
	 * 	suffix: "F",
	 * 	description: "My Metric Description",
	 * 	default_value: 1
	 * }).then((metric) => {
	 * 	// metric = {@link Metric}
	 * }).catch((error) => { })
	 */
	async addMetric(metric){
		let response 

		let url = "/v1/metrics"

		try {
			response = await this.api.post(url, metric)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete a Metric
	 * @param  {Integer} metric_id - The ID of the Metric you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if Metric deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteMetric(0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteMetric(0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteMetric(metric_id){
		let response 

		let url = "/v1/metrics/" + metric_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}
	/**
	 * @typedef {Object} MetricPoint
	 * @property {Number} value - Value to plot on the metric graph
	 * @property {Timestamp} [timestamp] - Unix timestamp of the point was measured
	 */
	/**
	 * Get all the Metric Points
	 * @param  {Integer} metric_id - The ID of the Metric you wish to get Metric Points from
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;MetricPoint>>} Returns an Array of Components
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let metric_point = await cachet_api.getMetricPoints(0)
	 * // metric_point = [{@link MetricPoint}, {@link MetricPoint}, {@link MetricPoint}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getMetricPoints(0).then((metric_point) => {
	 * 	// metric_point = [{@link MetricPoint}, {@link MetricPoint}, {@link MetricPoint}]
	 * }).catch((error) => { })
	 */
	async getMetricPoints(metric_id){
		let response 

		let url = "/v1/metrics/" + metric_id + "/points"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Component
	 * @param  {Integer} metric_id - The ID of the Metric you wish to add a Metric Point to
	 * @param  {MetricPoint} point - The Metric Point you wish to add
	 * @return {Promise&lt;MetricPoint>} Returns a MetricPoint
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let metric_point = await cachet_api.addMetricPoint({
	 * 	value: 0.75
	 * })
	 * // metric_point = {@link MetricPoint}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addMetricPoint({
	 * 	value: 0.75
	 * }).then((metric_point) => {
	 * 	// metric_point = {@link MetricPoint}
	 * }).catch((error) => { })
	 */
	async addMetricPoint(metric_id, point){
		let response 

		let url = "/v1/metrics/" + metric_id + "/points"

		try {
			response = await this.api.post(url, point)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete a Metric Point
	 * @param  {Integer} metric_id - The ID of the Metric you wish to delete a Metric Point from
	 * @param  {Integer} point_id - The ID of the Metric Point you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if Metric Point deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteMetricPoint(0, 0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteMetricPoint(0, 0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteMetricPoint(metric_id, point_id){
		let response 

		let url = "/v1/metrics/" + metric_id + "/points/" + point_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- SUBSCRIBERS ----------------- */
	/**
	 * @typedef {Object} Subscriber
	 * @property {String} email - Name of the Component
	 * @property {Boolean} [verify] - Whether the Component is enabled
	 * @property {Array.&lt;Integer>} [components="*"] - Array of component_id's that you wish to subscribe to
	 */
	/**
	 * Get all the Subscribers
	 * @param  {boolean} [with_meta=false] - Set this to true if you would like the original response with meta info (paginated info)
	 * @return {Promise&lt;Array.&lt;Subscriber>>} Returns an Array of Subscribers
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let subscribers = await cachet_api.getSubscribers()
	 * // subscribers = [{@link Subscriber}, {@link Subscriber}, {@link Subscriber}]
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.getSubscribers().then((subscribers) => {
	 * 	// subscribers = [{@link Subscriber}, {@link Subscriber}, {@link Subscriber}]
	 * }).catch((error) => { })
	 */
	async getSubscribers(){
		let response 

		let url = "/v1/subscribers"

		try {
			response = await this.api.get(url)
		} catch (e) {
			throw this.createError(url, 'GET', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Add a new Subscriber
	 * @param  {Subscriber} subscriber - The Subscriber you wish to add
	 * @return {Promise&lt;Subscriber>} Returns a Subscriber
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let subscriber = await cachet_api.addSubscriber({
	 * 	email: "email@example.com"
	 * })
	 * // subscriber = {@link Subscriber}
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.addSubscriber({
	 * 	email: "email@example.com"
	 * }).then((subscriber) => {
	 * 	// subscriber = {@link Subscriber}
	 * }).catch((error) => { })
	 */
	async addSubscriber(subscriber){
		let response 

		let url = "/v1/subscribers"

		try {
			response = await this.api.post(url, subscriber)
		} catch (e) {
			throw this.createError(url, 'POST', e)
		}

		// axios wraps in data AND cachet wraps in data. Unwrap both.
		return response.data.data
	}
	/**
	 * Delete a Subscriber
	 * @param  {Integer} subscriber_id - The ID of the Subscriber you wish to delete
	 * @return {Promise&lt;Boolean>} Returns `true` if Subscriber deletion was successful
	 * 
	 * @example &lt;caption>Async/Await&lt;/caption>
	 * let success = await cachet_api.deleteSubscriber(0)
	 * // success = true
	 *
	 * @example &lt;caption>Promise&lt;/caption>
	 * cachet_api.deleteSubscriber(0).then((success) => {
	 * 	// success = true
	 * }).catch((error) => { })
	 */
	async deleteSubscriber(subscriber_id){
		let response 

		let url = "/v1/subscribers/" + subscriber_id

		try {
			response = await this.api.delete(url)
		} catch (e) {
			throw this.createError(url, 'DELETE', e)
		}

		// Since nothing is returned from the API other than `204`, return true
		return true
	}

	/* ----------------- Utilities ----------------- */
	createError(url, type, error){
		var extraErrorText = "";

		if (error &amp;&amp; error.response){
			if (error.response.status)
				extraErrorText += error.response.status + " "
			if (error.response.statusText)
				extraErrorText += error.response.statusText + " | "
			if (error.response.data)
				extraErrorText += JSON.stringify(error.response.data)
		} else {
			extraErrorText = error.toString()
		}

		console.error(error)
		
		return new Error("Unable to " + type + " " + url + ": " + extraErrorText)
	}
}

module.exports = CachetAPI</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  
  
</body>
</html>
